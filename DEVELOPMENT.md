# Development Guide: podfeedfilter

*Generated by AI evaluation on 2025-08-29*

## Getting Started

### Prerequisites

- **Python 3.10+** (required for modern type hint syntax)
- **Git** for version control
- **pip** for dependency management

### Environment Setup

1. **Clone the repository**:
   ```bash
   git clone <repository-url>
   cd podfeedfilter
   ```

2. **Create virtual environment**:
   ```bash
   python -m venv .venv
   source .venv/bin/activate  # On Windows: .venv\Scripts\activate
   ```

3. **Install dependencies**:
   ```bash
   # Core dependencies
   pip install -r requirements.txt
   
   # Development dependencies (includes core)
   pip install -r requirements-dev.txt
   ```

4. **Verify installation**:
   ```bash
   python -m podfeedfilter --help
   pytest -v
   ```

## Project Structure

### Core Modules
```
podfeedfilter/
├── __init__.py          # Package metadata and docstring
├── __main__.py          # CLI entry point (43 lines)
├── config.py            # Configuration parsing (75 lines)
└── filterer.py          # Core processing logic (186 lines)
```

### Supporting Files
```
├── feeds.yaml           # Sample configuration file
├── requirements.txt     # Core dependencies
├── requirements-dev.txt # Development dependencies
├── pytest.ini          # Test configuration
├── .pylintrc           # Code quality configuration
├── .gitignore          # Git ignore patterns
└── .github/
    └── workflows/       # CI/CD pipeline definitions
```

### Test Suite
```
tests/ (13 files, 172 tests, 3,883 lines)
├── test_cli.py                     # CLI interface tests
├── test_config_*.py               # Configuration parsing (4 files)
├── test_conditional_fetch.py      # HTTP optimization tests
├── test_edge_cases.py             # Edge case and error handling
├── test_feedparser_mock.py        # Mock framework tests
├── test_filterer.py               # Core filtering logic
├── test_private_*.py              # Privacy features (3 files)
├── test_process_feed_integration.py # End-to-end integration
├── test_splits_integration.py     # Feed splitting tests
├── conftest.py                    # Shared test fixtures
└── data/                          # Test data and fixtures
```

## Development Workflow

### 1. Feature Development

**Branch Strategy**:
```bash
# Create feature branch from main
git checkout main
git pull origin main
git checkout -b feature/your-feature-name

# Make changes, commit regularly
git add .
git commit -m "Add feature: description"

# Push and create pull request
git push origin feature/your-feature-name
```

**Development Cycle**:
1. Write failing tests first (TDD approach)
2. Implement minimal code to make tests pass
3. Refactor for clarity and maintainability
4. Ensure 100% test coverage on modified modules
5. Run full test suite and linting

### 2. Testing Strategy

**Run Tests**:
```bash
# Run all tests with coverage
pytest

# Run specific test file
pytest tests/test_filterer.py

# Run tests matching pattern
pytest -k "test_private"

# Run with verbose output
pytest -v

# Generate coverage report
pytest --cov-report=html
open htmlcov/index.html  # View coverage report
```

**Test Categories**:
- **Unit Tests**: Test individual functions in isolation
- **Integration Tests**: Test complete workflows end-to-end
- **Edge Case Tests**: Test error conditions and boundary cases
- **Performance Tests**: Verify performance with large datasets

### 3. Code Quality

**Linting and Style**:
```bash
# Run pylint on all Python files
pylint $(git ls-files '*.py')

# Check specific file
pylint podfeedfilter/config.py

# Generate lint report
pylint $(git ls-files '*.py') --output=lint_report.txt
```

**Code Style Guidelines**:
- Follow PEP 8 style guidelines
- Use modern Python features (3.10+ syntax)
- Comprehensive docstrings for all functions/classes
- Type hints for all function parameters and returns
- Descriptive variable and function names

### 4. Debugging

**Local Development**:
```bash
# Run with sample config
python -m podfeedfilter -c feeds.yaml

# Force refresh (bypass caching)
python -m podfeedfilter -c feeds.yaml --no-check-modified

# Override privacy settings
python -m podfeedfilter -c feeds.yaml --private false
```

**Debug Testing**:
```bash
# Run specific test with output
pytest tests/test_filterer.py::TestFilterer::test_text_matches -s

# Debug with pdb
pytest --pdb tests/test_config_load.py::test_load_basic_config

# Stop on first failure
pytest -x
```

## Code Standards

### 1. Python Style

**Type Hints** (Required):
```python
# Good: Complete type annotations
def process_feed(cfg: FeedConfig, no_check_modified: bool = False) -> None:
    """Process a single feed with type safety."""
    pass

# Bad: Missing type hints
def process_feed(cfg, no_check_modified=False):
    pass
```

**Modern Python Syntax** (Required):
```python
# Good: Python 3.10+ union syntax
def get_title(self) -> str | None:
    return self.title

# Bad: Old-style Optional
from typing import Optional
def get_title(self) -> Optional[str]:
    return self.title
```

**Dataclasses** (Preferred):
```python
# Good: Dataclass with defaults
@dataclass
class FeedConfig:
    url: str
    output: str
    include: List[str] = field(default_factory=list)
    private: bool = True

# Acceptable: Traditional class (only when dataclass isn't suitable)
class CustomProcessor:
    def __init__(self, config: FeedConfig) -> None:
        self.config = config
```

### 2. Documentation Standards

**Function Docstrings** (Required):
```python
def _text_matches(text: str, keywords: list[str]) -> bool:
    """Check if text contains any of the specified keywords.
    
    Args:
        text: The text to search within (case-insensitive)
        keywords: List of keywords to search for
    
    Returns:
        True if any keyword is found in text, False otherwise
    
    Examples:
        >>> _text_matches("Python Programming", ["python", "java"])
        True
        >>> _text_matches("Hello World", ["goodbye"])
        False
    """
```

**Class Docstrings** (Required):
```python
@dataclass
class FeedConfig:
    """Configuration for a single podcast feed filtering task.
    
    This dataclass encapsulates all configuration needed to process
    a single feed, including source URL, filtering criteria, and
    output settings. Supports both simple filtering and advanced
    feed splitting scenarios.
    
    Attributes:
        url: Source RSS feed URL
        output: Output file path for filtered feed
        include: Keywords that must be present (empty = no filter)
        exclude: Keywords that must not be present (empty = no filter)
        title: Optional override for feed title
        description: Optional override for feed description
        check_modified: Enable HTTP conditional requests (default: True)
        private: Add iTunes block tag for privacy (default: True)
    """
```

### 3. Error Handling

**Exception Handling** (Best Practices):
```python
# Good: Specific exception handling with fallback
try:
    content, last_modified_ts = _conditional_fetch(cfg.url, file_mtime)
    if content is None:
        return  # 304 Not Modified, nothing to do
    remote = feedparser.parse(content)
except (requests.RequestException, ValueError) as e:
    print(f"Warning: Conditional fetch failed for {cfg.url}: {e}")
    print("Falling back to regular fetch...")
    remote = feedparser.parse(cfg.url)

# Bad: Broad exception catching
try:
    remote = feedparser.parse(cfg.url)
except Exception:
    pass  # Silent failure
```

**Input Validation**:
```python
# Good: Early validation with clear error messages
def load_config(path: str) -> List[FeedConfig]:
    """Parse the YAML config into a list of FeedConfig objects."""
    if not Path(path).exists():
        raise FileNotFoundError(f"Configuration file not found: {path}")
    
    with open(path, "r", encoding="utf-8") as f:
        try:
            data = yaml.safe_load(f) or {}
        except yaml.YAMLError as e:
            raise ValueError(f"Invalid YAML in {path}: {e}") from e
```

### 4. Testing Standards

**Test Function Naming**:
```python
# Good: Descriptive test names
def test_private_true_adds_itunes_block(self, tmp_path):
    """Test that private=True adds iTunes block tag."""

def test_conditional_fetch_returns_none_on_304_response(self):
    """Test conditional fetch handles 304 Not Modified correctly."""

# Bad: Unclear test names
def test_private(self):
def test_fetch(self):
```

**Test Structure** (Arrange-Act-Assert):
```python
def test_entry_passes_with_include_keywords(self):
    """Test that entries pass when matching include keywords."""
    # Arrange
    entry = {
        'title': 'Python Programming Tutorial',
        'description': 'Learn Python basics',
        'summary': ''
    }
    include = ['python', 'programming']
    exclude = []
    
    # Act
    result = _entry_passes(entry, include, exclude)
    
    # Assert
    assert result is True
```

**Mock Usage**:
```python
# Good: Mock external dependencies
@responses.activate
def test_conditional_fetch_with_last_modified(self):
    """Test conditional fetch with Last-Modified header."""
    # Mock HTTP response
    responses.add(
        responses.GET,
        "http://example.com/feed.xml",
        headers={"Last-Modified": "Wed, 21 Oct 2015 07:28:00 GMT"},
        body="<rss>...</rss>"
    )
    
    # Test the function
    content, timestamp = _conditional_fetch("http://example.com/feed.xml", None)
    assert content is not None
    assert timestamp is not None
```

## Configuration Management

### Sample Configuration

```yaml
# feeds.yaml - Sample configuration file
feeds:
  - url: "https://example.com/podcast1.rss"
    output: "podcast1_filtered.xml"
    exclude: ["politics", "advertisement"]
    private: true  # Default behavior
    
  - url: "https://example.com/podcast2.rss"  
    output: "podcast2_tech.xml"
    title: "Tech Episodes Only"
    description: "Filtered technology episodes"
    include: ["python", "programming", "technology"]
    private: false  # Public feed
    check_modified: true  # Enable caching (default)
    
    # Feed splitting: one source → multiple outputs
    splits:
      - output: "podcast2_beginner.xml"
        title: "Beginner Tech Episodes"
        include: ["beginner", "tutorial", "basics"]
        private: false
        
      - output: "podcast2_advanced.xml"
        include: ["advanced", "expert", "deep-dive"]
        exclude: ["beginner"]
        # private defaults to True, check_modified inherits from parent
```

### Configuration Testing

```python
# Test configuration parsing
def test_complex_config_parsing(self, tmp_path):
    """Test parsing complex configuration with splits."""
    config_content = """
feeds:
  - url: "http://example.com/feed.xml"
    output: "main.xml"
    include: ["tech"]
    exclude: ["politics"]
    private: false
    splits:
      - output: "split1.xml"
        include: ["python"]
        private: true
      - output: "split2.xml"
        exclude: ["advertisement"]
"""
    config_file = tmp_path / "config.yaml"
    config_file.write_text(config_content)
    
    feeds = load_config(str(config_file))
    
    assert len(feeds) == 3  # 1 main + 2 splits
    assert feeds[0].private is False  # main feed
    assert feeds[1].private is True   # split1
    assert feeds[2].private is True   # split2 (default)
```

## Performance Guidelines

### 1. HTTP Optimization

**Implement Conditional Requests**:
```python
def _conditional_fetch(url: str, since: float | None) -> tuple[bytes | None, float | None]:
    """Fetch URL with conditional request using If-Modified-Since header."""
    headers = {}
    if since is not None:
        headers["If-Modified-Since"] = email.utils.formatdate(since, usegmt=True)
    
    resp = requests.get(url, headers=headers, timeout=30)
    
    # Handle 304 Not Modified response
    if resp.status_code == 304:
        return None, None  # No changes since last fetch
    
    return resp.content, parse_last_modified_timestamp(resp)
```

**Smart Timestamp Management**:
```python
# Only update file timestamp when new content is added
if use_conditional_fetch and new_entries:
    if last_modified_ts is not None:
        os.utime(output_path, (last_modified_ts, last_modified_ts))
```

### 2. Memory Efficiency

**Stream Processing**:
- Process feeds one at a time
- Don't load entire feeds into memory unnecessarily
- Use generators where appropriate

**Append-Only Logic**:
```python
# Efficient: Only process new episodes
existing_ids: set[str] = set()
for entry in existing_entries:
    entry_id = str(entry.get('id') or entry.get('link'))
    existing_ids.add(entry_id)

# Skip episodes we've already processed
for entry in remote.entries:
    entry_id = entry.get('id') or entry.get('link')
    if entry_id in existing_ids:
        continue
    # Process only new episodes
```

### 3. Performance Testing

**Include Performance Benchmarks**:
```python
@pytest.mark.slow
def test_performance_with_large_feed(self):
    """Test performance with large feed (1,000 episodes)."""
    start_time = time.time()
    
    # Create large mock feed
    large_feed = create_mock_feed_with_n_episodes(1000)
    
    # Process feed
    process_feed(feed_config)
    
    # Verify performance constraint
    elapsed = time.time() - start_time
    assert elapsed < 10.0, f"Processing took {elapsed:.2f}s, should be < 10s"
```

## Debugging and Troubleshooting

### Common Issues

1. **Import Errors**:
   ```bash
   # Ensure virtual environment is activated
   source .venv/bin/activate
   pip list  # Verify dependencies installed
   ```

2. **Test Failures**:
   ```bash
   # Run with verbose output for details
   pytest -v --tb=long
   
   # Focus on specific failing test
   pytest tests/test_config_load.py::test_load_basic_config -v
   ```

3. **Coverage Issues**:
   ```bash
   # Generate detailed coverage report
   pytest --cov-report=html --cov-report=term-missing
   
   # Check which lines are missing coverage
   open htmlcov/index.html
   ```

### Development Tools

**Useful Commands**:
```bash
# Quick development checks
make test          # Run full test suite (if Makefile exists)
make lint          # Run code quality checks
make coverage      # Generate coverage report

# Manual commands
pytest -x          # Stop on first failure
pytest --lf        # Run last failed tests
pytest -k pattern  # Run tests matching pattern
pylint --errors-only podfeedfilter/  # Show only errors
```

**Editor Configuration**:
- Configure your editor for Python 3.10+ syntax highlighting
- Enable automatic formatting with `black` or similar
- Set up pylint integration for real-time feedback
- Configure pytest integration for in-editor test running

## Contributing Guidelines

### Pull Request Process

1. **Before Starting**:
   - Check existing issues and PRs
   - Discuss significant changes in issues first
   - Ensure you understand the project architecture

2. **Development Process**:
   - Create feature branch from `main`
   - Write tests for new functionality
   - Ensure existing tests pass
   - Maintain 100% coverage on core modules
   - Update documentation as needed

3. **Pull Request Requirements**:
   - Clear, descriptive PR title and description
   - Reference related issues
   - Include test coverage for new code
   - Update relevant documentation
   - Ensure CI passes (all Python versions)

4. **Code Review**:
   - Address all review feedback
   - Maintain backwards compatibility when possible
   - Follow existing patterns and conventions

### Release Process

1. **Version Management**:
   - Use semantic versioning (MAJOR.MINOR.PATCH)
   - Update version numbers in relevant files
   - Create git tags for releases

2. **Testing**:
   - Full test suite passes on all supported Python versions
   - Manual testing of CLI functionality
   - Performance regression testing

3. **Documentation**:
   - Update README.md with new features
   - Update configuration examples
   - Generate updated API documentation

This development guide provides comprehensive instructions for contributing to **podfeedfilter**. The project maintains high standards for code quality, testing, and documentation to ensure reliability and maintainability.
